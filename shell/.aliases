# vim: ft=sh tabstop=4 shiftwidth=4 expandtab list

# NOTE: for vipe, sponge etc install moreutils

# completion setups
# https://zsh.sourceforge.io/Doc/Release/Completion-System.html#Functions-2
_compdef () {
    # avoid compdef errors when sourcing this file for non-login/interactive shells
    compdef $@ 2>/dev/null
}
_unalias () {
    # avoid unalias errors when sourcing this file for non-login/interactive shells
    unalias $@ 2>/dev/null
}

_compdef _gnu_generic pdfgrep

# all aliases are functions in order to work with things like `notify` and `compdef`
_git 2>/dev/null # NOTE: loads the _git completion system, including subcommands

alias aliases='$EDITOR ~/.aliases'
alias up=unpack
alias nipe='vipe >/dev/null'

vipe() {
    [ -n "$1" -a "$1" != "--suffix" ] && { 2=$1; 1="--suffix" }
    command vipe $@
}

portusage() {
    netstat -anvp tcp | grep LISTEN | awk '{ print $4, $9 }' | while read port pid; do echo "Port $port: $(ps -p $pid -o command= | sed 's/^-//') (PID: $pid)"; done | sort -n | uniq
}

csvcol() {
    head -1 $2 | tr , '\n' | grep -n "^$1$" -m1 | cut -d: -f1
}

waitfor() {
    notify zsh -ic "while $*; do sleep 60; done"
}

tmp() {
    if [ "$1" = 'js' ]; then
        1='javascript'
    fi

    if [ -n $1 ]; then
        $EDITOR -c "set ft=$1" =()
    else
        $EDITOR $1 =()
    fi
}

js() {
    tmp javascript
}

git_exclude() {
    >> .git/info/exclude 2>/dev/null cat <<EOF
.in
.out
*.vim
EOF
}

largs() {
    tr '\n' '\0' | xargs -0 $@
}
_compdef _xargs largs

delete_old_branches() {
    list_old_branches | xargs -r git branch -d
}

list_old_branches() {
    git fetch -p && git for-each-ref --format '%(refname) %(upstream:track)' refs/heads | grep ' \[gone\]$' | cut -d' ' -f1 | sed 's|^refs/heads/||'
}

gmm() {
    git merge $(git rev-parse --abbrev-ref origin/HEAD | cut -d/ -f2-) $@
}
_compdef _git-merge gmm

glm() {
    gcom && gl
}
_compdef _git-pull glm

gslm() {
    g stash && glm; g stash pop
}
_compdef _git-pull gslm

closewords() {
    grep -E $(
        for i in $(seq 0 $(($(wc -c <<< "$1") - 2))); do
            sed -E "s/(.{$i}).(.*)/\1.\2/" <<< $1
        done | tr '\n' '|' | sed 's/^/^(/; s/|$/)$/'
    ) /usr/share/dict/words
}

rm() {
    trash $@
}
_compdef _trash rm

zshman () {
    man zshbuiltins | less -p "^       $1 "
}

edittmux() {
    nvim ~/.config/tmux/tmux.conf && tmux source ~/.config/tmux/tmux.conf
}

python() {
    python3 $@
}

unpack() {
    unzip $1 && rm $1
}
_compdef '_files -g "*.zip"' unpack

blkrd() {
    grep -E ".|^$" $@
}

curlsh() {
    curl $@ | (sleep 3; cat) | nvim
}
# TODO: doesn't work
# _compdef _curl curlsh

set_service() {
    >> .in cat <<EOF
ORIGINAL_SERVICE_NAME=\$SERVICE_NAME
export SERVICE_NAME=$1
EOF

    >> .out cat <<EOF
export SERVICE_NAME=\$ORIGINAL_SERVICE_NAME
EOF

    source .in
}

create_venv() {
    python3 -m venv .venv
    >> .in cat <<EOF
source .venv/bin/activate
EOF
    >> .out cat <<EOF
deactivate
EOF
    source .in
}

_unalias ls
ls() {
    eza --group-directories-first $@
}

_unalias la
la() {
    ls -a $@ # ls -A for regular ls
}

_unalias ll
ll() {
    ls -lh $@
}

_unalias l
l() {
    ls -lah $@
}

cb() {
    pbcopy $@
}

pls() {
    sudo $(fc -ln -1)
}

cpd() {
    echo $(fc -ln -1) | perl -pe "chomp if eof" | cb # C-o now does this for current line
}

fzd() {
    cd ~/Documents; fzc
}

fzn() {
    nvim $(fzf) $@
}

cfzcn() {
    cd ~/.config; fzcn $@
}

fns() {
    fd Session.vim | fzf | xargs nvim -S $@
}

# lsz() {
#     du -sh * | sort -h
# }

# laz() {
#     { du -sh .*; du -sh * } 2>/dev/null | sort -h
# }

cupdate() {
    cargo install $(cargo install --list | sed -En "/:$/s/ .*//p")
}

cudeps() {
    cargo +nightly udeps
}

_unalias gl
gl() {
    git pull $(git remote) $(git rev-parse --abbrev-ref HEAD) $@
}
_compdef _git-pull gl

gsl() {
    git stash && git pull; git stash pop
}
_compdef _git-pull gsl

_unalias gco
gco() {
    local branch=$(git rev-parse --abbrev-ref HEAD)
    if [ "${branch}" = "main" ] || [ "$branch" = "master" ]; then
        echo -n "Do you want to pull changes first? (y/N) "
        read -rq pull
        [[ "${pull}" =~ [Yy] ]] && gl
    fi

    git checkout $@
}
_compdef _git-checkout gco

gcom() {
    git checkout $(git rev-parse --abbrev-ref origin/HEAD | cut -d/ -f2-) $@
}
_compdef _git-checkout gcom

gfm() {
    local branch=$(git rev-parse --abbrev-ref origin/HEAD | cut -d/ -f2-)
    git fetch origin ${branch}:${branch} $@
}
_compdef _git-fetch gfm

add() {
    awk '{s+=$1} END{print s}'
}

viewdoc() {
    open ./target/doc/$(basename $PWD)/index.html
}

alias priv=' BACKUP_HISTFILE=$HISTFILE; fc -p'
alias unpriv='HISTFILE=$BACKUP_HISTFILE'
alias top=bpytop
alias binja='/Applications/Binary\ Ninja.app/Contents/MacOS/binaryninja'
alias ra=ranger
alias m=tldr
alias c=cargo
alias timer=termdown
alias yeah=yes
alias q=" exit"
alias v=vr
alias n=nvim
alias sl=ls
alias ks=ls


_gon() {
    urls=$(rg "url =" $(git rev-parse --show-toplevel)/.git/config | sed -E "s|.*url = ||; s|.*@([^:]+):(.*)|https://\1/\2|; s|.git$||")

    if [ $(wc -l <<< $urls) -ne 1 ]; then
        urls=$(fzf --header "Select URL:" <<< $urls)
    fi

    open $urls
}
alias gon=' _gon'


## actual functions

np() {
    [ -z "$1" ] && return
    mkdir -p "$(basename "$1")" \
        && nvim "$1"
}

cl() {
    curl "$@" -o "$(sed 's/\?.*//' <<< $(basename "$1"))"
}
# TODO: doesn't work
# _compdef _curl cl

ctfetch() {
    file=$(basename "$1")
    wget $@ && mv "$file" $(sed 's/\?.*//' <<< $file)
}
_compdef _wget ctfetch

notify() {
    if $@; then
        title="Succeeded"
    else
        title="Failed"
    fi
    osascript -e "display notification \"$*\" with title \"${title}\""
}

gcls() {
    [ $# -lt 2 ] && echo "err: need branch & repo to clone" && return
    cd $(faketty git clone --depth 1 --branch "$1" "$(sed -E 's|.*//(git@)?(.*)\.([^./]*)/|git@\2.\3:|; s|/src/.*$||' <<< ${2})" ${@:3} |& tee $(tty) | sed -En "/Cloning into/s/.*'(.*)'...\r/\1/p")
}
_compdef _git-clone gcls

gclb() {
    [ $# -lt 1 ] && echo "err: need repo to clone" && return
    cd $(faketty git clone --bare "$(sed -E 's|.*//(git@)?(.*)\.([^./]*)/|git@\2.\3:|; s|/src/.*$||' <<< $1)" ${@:2} |& tee $(tty) | sed -En "/Cloning into/s/.*'(.*)'...\r/\1/p")
}
_compdef _git-clone gclb

_unalias gcl
gcl() {
    [ $# -lt 1 ] && echo "err: need repo to clone" && return
    cd $(faketty git clone "$(sed -E 's|.*//(git@)?(.*)\.([^./]*)/|git@\2.\3:|; s|/src/.*$||' <<< $1)" ${@:2} |& tee $(tty) | sed -En "/Cloning into/s/.*'(.*)'...\r/\1/p")
}
_compdef _git-clone gcl

gw() {
    [ $# -lt 1 ] && 1="HEAD"
    git diff $1^ $1
}
_compdef _git-diff gw

cn() {
    cargo new $@ && cd $1
}

faketty() {
    script -qeF /dev/null $(printf "%q " "$@")
}

cr() {
    local output=$(perl -pe "s/\..*?$//" <<< "$1")
    gcc "$1" -o "$output" && ./$output
}

cman() {
    apropos "$1" |
        grep '(3)' |
        less
}

clean-none-images() {
    docker image ls |
        grep "^<none>" |
        awk '{print $3}' |
        xargs docker image rm
}

tldr() {
    [ $# -lt 1 ] && { command tldr; return; }
    command tldr "$@" | less
}

swap() {
    [ $# -ne 2 ] && echo "Usage: swap [file1] [file2]" && return
    local TMPFILE=$(mktemp)
    mv "$1" "$TMPFILE" && mv "$2" "$1" && mv "$TMPFILE" "$2" && rm "$TMPFILE"
}

fzc() {
    local file=$(fzf)
    cd $(echo $file | sed 's/\/[^\/]*$//') 2>/dev/null
}

fzcn() {
    local file=$(fzf)
    cd $(echo $file | sed 's/\/[^\/]*$//') 2>/dev/null
    nvim "$(echo "$file" | sed 's/.*\///')"
}

ns() {
    # very hacky workaround
    # to stop sessions with terminals starting in insert mode
    # TODO: modify vim-obsession to do this instead
    if [ -z "$1" ]; then
        gsed -i '/unlet SessionLoad/istopinsert' Session.vim &&
            nvim -S Session.vim
    else
        if [ $(compgen -G "$1*" | wc -l) -ne 1 ]; then
            echo "Too many matches for $1:"
            compgen -G "$1*"
            return 1
        fi

        gsed -i '/unlet SessionLoad/istopinsert' "./""$1"*"/Session.vim" &&
            nvim -S "./""$1""*/Session.vim"
    fi
}

mkcd() {
    mkdir -p "$1" && cd "$1"
}
