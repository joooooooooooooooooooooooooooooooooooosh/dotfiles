# vim: ft=bash tabstop=4 shiftwidth=4 expandtab list

# NOTE: for vipe, sponge etc install moreutils

# completion setups
# https://zsh.sourceforge.io/Doc/Release/Completion-System.html#Functions-2
_compdef() {
    # avoid compdef errors when sourcing this file for non-login/interactive shells
    type compdef &> /dev/null && compdef $@
}

_unalias() {
    # avoid unalias errors when sourcing this file for non-login/interactive shells
    unalias $@ 2>/dev/null
}

_compdef _gnu_generic pdfgrep

# all aliases are functions in order to work with things like `notify` and `compdef`
_git &> /dev/null # NOTE: loads the _git completion system, including subcommands

alias aliases='$EDITOR ~/.aliases'
alias up=unpack
alias nipe='vipe >/dev/null'
alias tipe='tee $(tty) | nipe'
alias fileserver='python3 -m http.server 8080'
alias ssl='local-ssl-proxy --cert ~/.misc/localhost.pem --key ~/.misc/localhost-key.pem --source 3000 --target 8080'
# Used in custom bira.zsh-theme to disable status reporting for large repositories
alias disable_status='git config prompt.git-status false'
alias enable_status='git config --unset prompt.git-status'
alias espanso=/opt/homebrew/bin/espanso

export MANPAGER="sh -c 'col -bx | bat -l man -p'"

psgrep() {
    ps aux | grep "$@" | grep -v "grep .*$*"
}

watch() {
    while :; do clear; date; echo; "$@"; sleep 2; done
}

nat() {
    cat $1 | nipe $2
}

dump() {
    objdump -d -Mintel "$@" | nipe objdump
}

findlock() {
    ioreg -l -w 0 \
        | perl -nle 'print $1 if /"kCGSSessionSecureInputPID"=(\d+)/' \
        | uniq \
        | xargs -I{} ps -p {} -o comm=
}

vipe() {
    if [ -n "$1" -a "$1" != "--suffix" ]; then
        2=$1
        1="--suffix"
    fi
    command vipe "$@"
}

portusage() {
    netstat -anvp tcp | grep LISTEN | awk '{ print $4, $9 }' | while read port pid; do echo "Port $port: $(ps -p $pid -o command= | sed 's/^-//') (PID: $pid)"; done | sort -n | uniq
}

csvcol() {
    head -1 $2 | tr , '\n' | grep -n "^$1$" -m1 | cut -d: -f1
}

waitfor() {
    notify zsh -ic "while $*; do sleep 60; done"
}

tmp() {
    if [ "$1" = 'js' ]; then
        1='javascript'
    fi

    if [ -n $1 ]; then
        $EDITOR -c "set ft=$1" =()
    else
        $EDITOR $1 =()
    fi
}

js() {
    tmp javascript
}

git_exclude() {
    >> .git/info/exclude 2> /dev/null cat << EOF
.in
.out
*.vim
EOF
}

zargs() {
    xargs -I{} "$@" {}
}
_compdef _xargs zargs

largs() {
    tr '\n' '\0' | xargs -0 "$@"
}
_compdef _xargs largs

lzargs() {
    tr '\n' '\0' | zargs -0 "$@"
}
_compdef _xargs lzargs

delete_old_branches() {
    list_old_branches | xargs -r git branch -d
}

list_old_branches() {
    git fetch -qp && git for-each-ref --format '%(refname) %(upstream:track)' refs/heads | grep ' \[gone\]$' | cut -d' ' -f1 | sed 's|^refs/heads/||'
}

gmm() {
    git merge $(gshm) "$@"
}
_compdef _git-merge gmm

glm() {
    gcom && gl
}
_compdef _git-pull glm

gslm() {
    git stash && glm
    git stash pop
}
_compdef _git-pull gslm

closewords() {
    grep -E $(
        for i in $(seq 0 $(($(wc -c <<< "$1") - 2))); do
            sed -E "s/(.{$i}).(.*)/\1.\2/" <<< $1
        done | tr '\n' '|' | sed 's/^/^(/; s/|$/)$/'
    ) /usr/share/dict/words
}

rm() {
    trash "$@"
}
_compdef _trash rm

zshman() {
    man zshbuiltins | less -p "^       $1 "
}

edittmux() {
    nvim ~/.config/tmux/tmux.conf && tmux source ~/.config/tmux/tmux.conf
}

python() {
    python3 "$@"
}

unpack() {
    unzip $1 && rm $1
}
_compdef '_files -g "*.zip"' unpack

blkrd() {
    grep -E ".|^$" "$@"
}

curlsh() {
    curl "$@" | (
        sleep 3
        cat
    ) | nipe sh
}
# TODO: doesn't work
# _compdef _curl curlsh

set_service() {
    >> .in cat << EOF
ORIGINAL_SERVICE_NAME=\$SERVICE_NAME
export SERVICE_NAME=$1
EOF

    >> .out cat << EOF
export SERVICE_NAME=\$ORIGINAL_SERVICE_NAME
EOF

    source .in
}

create_venv() {
    python3 -m venv .venv
    >> .in cat << EOF
source .venv/bin/activate
EOF
    >> .out cat << EOF
deactivate
EOF
    source .in
}

_unalias ls
ls() {
    eza --group-directories-first "$@"
}

_unalias la
la() {
    ls -a "$@" # ls -A for regular ls
}

_unalias ll
ll() {
    ls -lh "$@"
}

_unalias l
l() {
    ls -lah "$@"
}

cb() {
    pbcopy "$@"
}

pls() {
    sudo $(fc -ln -1)
}

cpd() {
    echo $(fc -ln -1) | perl -pe "chomp if eof" | cb # C-o now does this for current line
}

fzd() {
    cd ~/Documents
    fzc
}

fzn() {
    nvim $(fzf) "$@"
}

cfzcn() {
    cd ~/.config
    fzcn "$@"
}

fns() {
    fd Session.vim | fzf | xargs nvim -S "$@"
}

# lsz() {
#     du -sh * | sort -h
# }

# laz() {
#     { du -sh .*; du -sh * } 2>/dev/null | sort -h
# }

cupdate() {
    cargo install $(cargo install --list | sed -En "/:$/s/ .*//p")
}

cudeps() {
    cargo +nightly udeps
}

gshm() {
    git rev-parse --abbrev-ref origin/HEAD | cut -d/ -f2-
}

_unalias gl
gl() {
    git pull $(git remote) $(git rev-parse --abbrev-ref HEAD) "$@"
}
_compdef _git-pull gl

gsl() {
    git stash && git pull
    git stash pop
}
_compdef _git-pull gsl

_unalias gco
gco() {
    if [ "${1}" = "-b" ]; then
        echo -n "Do you want to pull changes first? (y/N) "
        read -rq pull
        [[ ${pull} =~ [Yy] ]] && gl
    fi

    git checkout "$@"
}
_compdef _git-checkout gco

gcom() {
    git checkout $(gshm) "$@"
}
_compdef _git-checkout gcom

gsco() {
    g stash && gco "$@"
    g stash pop
}
_compdef _git-checkout gsco

gfm() {
    git fetch origin $(gshm):$(gshm) "$@"
}
_compdef _git-fetch gfm

add() {
    awk '{s+=$1} END{print s}'
}

viewdoc() {
    open ./target/doc/$(basename $PWD)/index.html
}

alias priv=' BACKUP_HISTFILE=$HISTFILE; fc -p'
alias unpriv='HISTFILE=$BACKUP_HISTFILE'
alias top=bpytop
alias binja='/Applications/Binary\ Ninja.app/Contents/MacOS/binaryninja'
alias ra=ranger
alias m=tldr
alias c=cargo
alias timer=termdown
alias yeah=yes
alias q=" exit"
alias v=vr
alias sl=ls
alias ks=ls

_gon() {
    urls=$(rg "url =" $(git rev-parse --show-toplevel)/.git/config | sed -E "s|.*url = ||; s|.*@([^:]+):(.*)|https://\1/\2|; s|.git$||")

    if [ $(wc -l <<< $urls) -ne 1 ]; then
        urls=$(fzf --header "Select URL:" <<< $urls)
    fi

    open $urls
}
alias gon=' _gon'

_gonc() {
    gon
    exit
}
alias gonc=' _gonc'

## actual functions

default_nvim() {
    echo $1 > .default.nvim
    [ -d .git ] && ! grep -qF .default.nvim .git/info/exclude && echo .default.nvim >> .git/info/exclude
}

n() {
    if [ -z "$1" ]; then
        1=$(cat .default.nvim 2>/dev/null) || {
            1='-c'
            2='Telescope find_files'
        }
    fi
    nvim "$@"
}

np() {
    [ -z "$1" ] && return
    mkdir -p "$(basename "$1")" \
        && nvim "$1"
}

cl() {
    curl "$@" -o "$(sed 's/\?.*//' <<< $(basename "$1"))"
}
# TODO: doesn't work
# _compdef _curl cl

ctfetch() {
    file=$(basename "$1")
    wget "$@" && mv "$file" $(sed 's/\?.*//' <<< $file)
}
_compdef _wget ctfetch

notify() {
    if "$@"; then
        title="Succeeded"
    else
        title="Failed"
    fi
    osascript -e "display notification \"$*\" with title \"${title}\""
}

gcls() {
    [ $# -lt 2 ] && echo "err: need branch & repo to clone" && return
    cd $(faketty git clone --depth 1 --branch "$1" "$(sed -E 's|.*//(git@)?(.*)\.([^./]*)/|git@\2.\3:|; s_/(src|tree)/.*$__' <<< ${2})" ${@:3} |& tee $(tty) | sed -En "/Cloning into/s/.*'(.*)'...\r/\1/p")
}
_compdef _git-clone gcls

gclb() {
    [ $# -lt 1 ] && echo "err: need repo to clone" && return
    cd $(faketty git clone --bare "$(sed -E 's|.*//(git@)?(.*)\.([^./]*)/|git@\2.\3:|; s_/(src|tree)/.*$__' <<< $1)" ${@:2} |& tee $(tty) | sed -En "/Cloning into/s/.*'(.*)'...\r/\1/p")
}
_compdef _git-clone gclb

_unalias gcl
gcl() {
    [ $# -lt 1 ] && echo "err: need repo to clone" && return
    cd $(faketty git clone "$(sed -E 's|.*//(git@)?(.*)\.([^./]*)/|git@\2.\3:|; s_/(src|tree)/.*$__' <<< $1)" ${@:2} |& tee $(tty) | sed -En "/Cloning into/s/.*'(.*)'...\r/\1/p")
}
_compdef _git-clone gcl

gln() {
    gl "$@" && n
}

gcln() {
    gcl "$@" && n
}

gw() {
    [ $# -lt 1 ] && 1="HEAD"
    git diff $1^ $1
}
_compdef _git-diff gw

faketty() {
    script -qeF /dev/null $(printf "%q " "$@")
}

cr() {
    local output=$(perl -pe "s/\..*?$//" <<< "$1")
    gcc "$1" -o "$output" && ./$output
}

cman() {
    apropos "$1" \
        | grep '(3)' \
        | less
}

clean-none-images() {
    docker image ls \
        | grep "^<none>" \
        | awk '{print $3}' \
        | xargs docker image rm
}

tldr() {
    [ $# -lt 1 ] && {
        command tldr
        return
    }
    command tldr "$@" | less
}

swap() {
    [ $# -ne 2 ] && echo "Usage: swap [file1] [file2]" && return
    local TMPFILE=$(mktemp)
    mv "$1" "$TMPFILE" && mv "$2" "$1" && mv "$TMPFILE" "$2" && rm "$TMPFILE"
}

fzc() {
    local file=$(fzf)
    cd $(echo $file | sed 's/\/[^\/]*$//') 2> /dev/null
}

fzcn() {
    local file=$(fzf -q "$@")
    cn $file
}

cn() {
    cd $(echo "$1" | sed 's/\/[^\/]*$//') 2> /dev/null
    nvim "$(echo "$1" | sed 's/.*\///')"
}

ns() {
    # very hacky workaround
    # to stop sessions with terminals starting in insert mode
    # TODO: modify vim-obsession to do this instead
    if [ -z "$1" ]; then
        gsed -i '/unlet SessionLoad/istopinsert' Session.vim \
            && nvim -S Session.vim
    else
        if [ $(compgen -G "$1*" | wc -l) -ne 1 ]; then
            echo "Too many matches for $1:"
            compgen -G "$1*"
            return 1
        fi

        gsed -i '/unlet SessionLoad/istopinsert' "./""$1"*"/Session.vim" \
            && nvim -S "./""$1""*/Session.vim"
    fi
}

mkcd() {
    mkdir -p "$1" && cd "$1"
}

zn() {
    z "$@"
    n
}

zin() {
    zi "$@"
    n
}

#### nvm setup

_lazy_load_nvm() {
    unset -f npm node nvm
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
}

npm() {
    _lazy_load_nvm
    npm "$@"
}

nvm() {
    _lazy_load_nvm
    nvm "$@"
}

node() {
    _lazy_load_nvm
    node "$@"
}

####

tz () {
        local from="Australia/Sydney"
        case "${2}" in
                (m) from="America/San_Francisco"  ;;
                (ny) from="America/New_York"  ;;
                (u) from="UTC"  ;;
                (i) from="Asia/Kolkata"  ;;
                (j) from="Asia/Tokyo"  ;;
                (a) from="Australia/Sydney"  ;;
                (nz) from="Pacific/Auckland"  ;;
        esac
        local time="${1:-$(date +"%H%M")}"
        convert_time "${time}" "${from}" Australia/Sydney
        convert_time "${time}" "${from}" America/Los_Angeles
        convert_time "${time}" "${from}" America/New_York
        convert_time "${time}" "${from}" UTC
        convert_time "${time}" "${from}" Asia/Kolkata
        convert_time "${time}" "${from}" Asia/Tokyo
        convert_time "${time}" "${from}" Pacific/Auckland
}

convert_time () {
        local hours="${1%??}"
        local minutes="${1: -2}"
        local from="${2}"
        local to="${3}"
        TZ="${to}" date -jf "%H:%M%z" "${hours}:${minutes}$(TZ="${from}" date +"%z")" +"%H:%M %Z (%z)"
}
